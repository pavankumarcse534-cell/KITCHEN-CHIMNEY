<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Three.js ‚Üí GLB: Kitchen Chimney Export</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { margin:0; font-family: Arial, Helvetica, sans-serif; }
    #canvas-wrap { width:100vw; height:80vh; display:block; position: relative; }
    #controls { padding:15px; background: #f5f5f5; border-bottom: 1px solid #ddd; display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
    button { padding:8px 16px; border-radius:6px; border: 1px solid #ccc; background: white; cursor: pointer; font-size: 14px; transition: all 0.2s; }
    button:hover { background: #e0e0e0; border-color: #999; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    input[type="file"] { display: none; }
    #url-input { padding:8px 12px; width:300px; border: 1px solid #ccc; border-radius: 6px; font-size: 14px; }
    #status { margin-left:12px; color: #666; font-size: 14px; }
    .file-info { padding: 8px 12px; background: #e8f5e9; border: 1px solid #4caf50; border-radius: 6px; margin: 8px 0; display: flex; align-items: center; gap: 8px; }
    .file-info span { font-size: 13px; color: #2e7d32; }
    .error-message { padding: 8px 12px; background: #ffebee; border: 1px solid #f44336; border-radius: 6px; margin: 8px 0; color: #c62828; font-size: 13px; }
    .loading-indicator { padding: 8px 12px; background: #e3f2fd; border: 1px solid #2196f3; border-radius: 6px; margin: 8px 0; color: #1565c0; font-size: 13px; display: flex; align-items: center; gap: 8px; }
    .loading-spinner { width: 14px; height: 14px; border: 2px solid #e3f2fd; border-top-color: #2196f3; border-radius: 50%; animation: spin 0.8s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }
    .drop-zone { border: 2px dashed #ccc; border-radius: 8px; padding: 20px; text-align: center; background: #fafafa; transition: all 0.3s; cursor: pointer; margin: 8px 0; }
    .drop-zone:hover { border-color: #999; background: #f0f0f0; }
    .drop-zone.dragover { border-color: #2196f3; background: #e3f2fd; }
    .drop-zone-text { color: #666; font-size: 14px; margin: 8px 0; }
    .file-input-label { display: inline-block; padding: 8px 16px; background: #2196f3; color: white; border-radius: 6px; cursor: pointer; font-size: 14px; transition: background 0.2s; }
    .file-input-label:hover { background: #1976d2; }
    .controls-section { display: flex; flex-direction: column; gap: 8px; }
    .controls-row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
  </style>
</head>
<body>
  <div id="canvas-wrap"></div>
  <div id="controls">
    <div class="controls-section" style="flex: 1; min-width: 300px;">
      <div class="controls-row">
        <label for="file-input" class="file-input-label">üìÅ Select GLB/GLTF File</label>
        <input type="file" id="file-input" accept=".glb,.gltf" />
        <button id="load-file">Load Selected File</button>
      </div>
      <div id="drop-zone" class="drop-zone">
        <div class="drop-zone-text">üì¶ Drag and drop GLB/GLTF file here</div>
        <div class="drop-zone-text" style="font-size: 12px; color: #999;">or click above to browse</div>
      </div>
      <div id="file-info" style="display: none;"></div>
      <div id="error-container" style="display: none;"></div>
      <div id="loading-container" style="display: none;"></div>
    </div>
    <div class="controls-section" style="flex: 1; min-width: 300px;">
      <div class="controls-row">
        <input type="text" id="url-input" placeholder="Enter model URL (e.g., ./media/uploads/model.glb)" />
        <button id="load-url">Load from URL</button>
      </div>
      <div class="controls-row">
        <button id="export-scene">Export Scene to GLB</button>
        <button id="export-chimney">Export Chimney Only</button>
        <button id="load-sample">Load Demo Model</button>
      </div>
    </div>
    <div style="flex-basis: 100%;">
      <span id="status"></span>
    </div>
  </div>
  <!-- Three.js from CDN (module) -->
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/controls/OrbitControls.js';
    import { GLTFExporter } from 'https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/exporters/GLTFExporter.js';
    import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/loaders/GLTFLoader.js';

    // Scene / renderer / camera
    const wrap = document.getElementById('canvas-wrap');
    const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
    renderer.setSize(wrap.clientWidth, wrap.clientHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    wrap.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf6f6f6);

    const camera = new THREE.PerspectiveCamera(45, wrap.clientWidth / wrap.clientHeight, 0.1, 1000);
    camera.position.set(3, 2, 5);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 1, 0);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.enablePan = true;
    controls.enableRotate = true;
    controls.enableZoom = true;
    controls.minDistance = 0.5;
    controls.maxDistance = 100;
    controls.minPolarAngle = 0;
    controls.maxPolarAngle = Math.PI;
    controls.panSpeed = 1;
    controls.rotateSpeed = 0.5;
    controls.zoomSpeed = 1;
    controls.screenSpacePanning = false;
    controls.update();

    // Lights
    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
    hemi.position.set(0, 5, 0);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(5, 10, 7.5);
    scene.add(dir);

    // Floor
    const floorMat = new THREE.MeshStandardMaterial({ metalness: 0, roughness: 0.9 });
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(20, 20), floorMat);
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = 0;
    scene.add(floor);

    // Group to hold chimney
    const chimneyGroup = new THREE.Group();
    chimneyGroup.name = "KitchenChimney";
    scene.add(chimneyGroup);

    // Track loaded model for export
    let loadedModel = null;
    let currentFile = null;

    // Helper functions for UI updates
    function updateStatus(message, type = 'info') {
      const statusEl = document.getElementById('status');
      statusEl.textContent = message;
      statusEl.style.color = type === 'error' ? '#c62828' : type === 'success' ? '#2e7d32' : '#666';
    }

    function showFileInfo(file) {
      const fileInfoEl = document.getElementById('file-info');
      const fileSize = (file.size / 1024 / 1024).toFixed(2);
      fileInfoEl.innerHTML = `
        <div class="file-info">
          <span>üìÑ ${file.name} (${fileSize} MB)</span>
        </div>
      `;
      fileInfoEl.style.display = 'block';
      currentFile = file;
    }

    function hideFileInfo() {
      document.getElementById('file-info').style.display = 'none';
      currentFile = null;
    }

    function showError(message) {
      const errorEl = document.getElementById('error-container');
      errorEl.innerHTML = `<div class="error-message">‚ùå ${message}</div>`;
      errorEl.style.display = 'block';
      setTimeout(() => {
        errorEl.style.display = 'none';
      }, 5000);
    }

    function hideError() {
      document.getElementById('error-container').style.display = 'none';
    }

    function showLoading(message = 'Loading...') {
      const loadingEl = document.getElementById('loading-container');
      loadingEl.innerHTML = `
        <div class="loading-indicator">
          <div class="loading-spinner"></div>
          <span>${message}</span>
        </div>
      `;
      loadingEl.style.display = 'block';
    }

    function hideLoading() {
      document.getElementById('loading-container').style.display = 'none';
    }

    // Validate GLB file
    function validateGLBFile(file) {
      const extension = file.name.split('.').pop()?.toLowerCase();
      if (extension !== 'glb' && extension !== 'gltf') {
        showError('Invalid file type. Please select a .glb or .gltf file.');
        return false;
      }
      if (file.size === 0) {
        showError('File is empty. Please select a valid file.');
        return false;
      }
      // Warn for very large files (>100MB)
      if (file.size > 100 * 1024 * 1024) {
        if (!confirm(`File is large (${(file.size / 1024 / 1024).toFixed(2)} MB). Loading may take a while. Continue?`)) {
          return false;
        }
      }
      return true;
    }

    // Simple chimney builder (replace with your model)
    function buildChimney(group) {
      // Base hood (box)
      const hoodGeo = new THREE.BoxGeometry(1.6, 0.2, 0.8);
      const hoodMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8, roughness: 0.25 });
      const hood = new THREE.Mesh(hoodGeo, hoodMat);
      hood.position.set(0, 1.4, 0);
      hood.name = "Hood";
      group.add(hood);

      // Chimney stack (tall box)
      const stackGeo = new THREE.BoxGeometry(0.5, 1.6, 0.5);
      const stackMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.85, roughness: 0.2 });
      const stack = new THREE.Mesh(stackGeo, stackMat);
      stack.position.set(0, 2.2, 0);
      stack.name = "Stack";
      group.add(stack);

      // Inside vent cut (a smaller box as simulated opening)
      const ventGeo = new THREE.BoxGeometry(1.2, 0.12, 0.4);
      const ventMat = new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.9, roughness: 0.25 });
      const vent = new THREE.Mesh(ventGeo, ventMat);
      vent.position.set(0, 1.31, 0.18);
      vent.name = "Vent";
      group.add(vent);

      // Decorative flange
      const flangeGeo = new THREE.BoxGeometry(0.05, 0.2, 0.8);
      const flange1 = new THREE.Mesh(flangeGeo, hoodMat);
      flange1.position.set(-0.8, 1.4, 0);
      const flange2 = flange1.clone();
      flange2.position.set(0.8, 1.4, 0);
      group.add(flange1, flange2);

      // Adjustable transform
      group.position.set(0, 0, 0);
    }

    buildChimney(chimneyGroup);

    // Load model from file input
    async function loadModelFromFile(file) {
      if (!validateGLBFile(file)) {
        return;
      }

      hideError();
      showLoading('Loading model from file...');
      updateStatus('Loading model from file...', 'info');
      showFileInfo(file);
      
      const loader = new GLTFLoader();
      const reader = new FileReader();
      
      return new Promise((resolve, reject) => {
        reader.onload = (e) => {
          try {
            const arrayBuffer = e.target.result;
            
            loader.parse(arrayBuffer, '', gltf => {
              processLoadedModel(gltf.scene || gltf.scenes[0]);
              updateStatus(`Model loaded: ${file.name}`, 'success');
              hideLoading();
              resolve(gltf.scene || gltf.scenes[0]);
            }, error => {
              const errorMsg = `Failed to load model: ${error.message || 'Unknown error'}`;
              updateStatus(errorMsg, 'error');
              showError(errorMsg);
              hideLoading();
              reject(error);
            });
          } catch (error) {
            const errorMsg = `Error parsing file: ${error.message || 'Unknown error'}`;
            updateStatus(errorMsg, 'error');
            showError(errorMsg);
            hideLoading();
            reject(error);
          }
        };
        
        reader.onerror = (error) => {
          const errorMsg = 'Failed to read file. Please try again.';
          updateStatus(errorMsg, 'error');
          showError(errorMsg);
          hideLoading();
          reject(error);
        };
        
        reader.readAsArrayBuffer(file);
      });
    }

    // Optionally load an external model from URL
    async function loadModel(url) {
      if (!url || url.trim() === '') {
        showError('Please enter a valid URL.');
        return;
      }

      hideError();
      hideFileInfo();
      showLoading('Loading model from URL...');
      updateStatus('Loading model from URL...', 'info');
      
      const loader = new GLTFLoader();
      return new Promise((resolve, reject) => {
        loader.load(
          url,
          gltf => {
            const model = gltf.scene || gltf.scenes[0];
            processLoadedModel(model);
            updateStatus('Model loaded successfully.', 'success');
            hideLoading();
            resolve(model);
          },
          (progress) => {
            if (progress.lengthComputable) {
              const percent = (progress.loaded / progress.total * 100).toFixed(0);
              showLoading(`Loading model from URL... ${percent}%`);
            }
          },
          err => {
            const errorMsg = `Failed to load model from URL: ${err.message || 'Unknown error'}`;
            updateStatus(errorMsg, 'error');
            showError(errorMsg);
            hideLoading();
            reject(err);
          }
        );
      });
    }

    // Process and add loaded model to scene
    function processLoadedModel(model) {
      // Remove existing loaded model if any
      if (loadedModel) {
        scene.remove(loadedModel);
        loadedModel = null;
      }

      model.name = "ImportedChimney";
      loadedModel = model;

      model.traverse(node => {
        if (node.isMesh && !(node.material instanceof THREE.MeshStandardMaterial)) {
          // convert to MeshStandardMaterial for better GLTF compatibility
          node.material = new THREE.MeshStandardMaterial({
            map: node.material.map || null,
            color: node.material.color || new THREE.Color(0xaaaaaa),
            metalness: 0.5,
            roughness: 0.5
          });
          node.castShadow = node.receiveShadow = true;
        }
      });

      // center & scale roughly
      const bbox = new THREE.Box3().setFromObject(model);
      const size = new THREE.Vector3();
      const center = new THREE.Vector3();
      bbox.getSize(size);
      bbox.getCenter(center);
      
      const maxDim = Math.max(size.x, size.y, size.z);
      if (maxDim > 0) {
        const scale = 1.5 / maxDim;
        model.scale.setScalar(scale);
      }

      // Center the model
      model.position.sub(center);
      model.position.y = 0.01;

      scene.add(model);
      
      // Update controls target to center of model
      controls.target.copy(center);
      controls.update();
      
      // Adjust camera position to fit model
      const distance = maxDim * 2.5;
      camera.position.set(distance, distance * 0.7, distance);
      camera.lookAt(center);
      controls.update();
    }

    // GLB export helpers
    function downloadArrayBuffer(buffer, filename) {
      const blob = new Blob([buffer], { type: 'model/gltf-binary' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = filename || 'scene.glb';
      document.body.appendChild(link);
      link.click();
      link.remove();
    }

    function exportToGLB(inputObject, options = {}) {
      return new Promise((resolve, reject) => {
        const exporter = new GLTFExporter();
        // exporter options:
        const exportOptions = {
          binary: true,
          ...options
        };
        exporter.parse(
          inputObject,
          glb => {
            if (glb instanceof ArrayBuffer) {
              resolve(glb);
            } else {
              // for json glTF
              const output = JSON.stringify(glb, null, 2);
              resolve(output);
            }
          },
          error => {
            reject(error);
          },
          exportOptions
        );
      });
    }

    // Drag and drop handlers
    const dropZone = document.getElementById('drop-zone');
    const fileInput = document.getElementById('file-input');

    // Prevent default drag behaviors
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      dropZone.addEventListener(eventName, preventDefaults, false);
      document.body.addEventListener(eventName, preventDefaults, false);
    });

    function preventDefaults(e) {
      e.preventDefault();
      e.stopPropagation();
    }

    // Highlight drop zone when item is dragged over it
    ['dragenter', 'dragover'].forEach(eventName => {
      dropZone.addEventListener(eventName, () => {
        dropZone.classList.add('dragover');
      }, false);
    });

    ['dragleave', 'drop'].forEach(eventName => {
      dropZone.addEventListener(eventName, () => {
        dropZone.classList.remove('dragover');
      }, false);
    });

    // Handle dropped files
    dropZone.addEventListener('drop', async (e) => {
      const dt = e.dataTransfer;
      const files = dt.files;
      
      if (files.length > 0) {
        const file = files[0];
        try {
          await loadModelFromFile(file);
        } catch (error) {
          console.error(error);
          // Error is already shown by loadModelFromFile
        }
      }
    }, false);

    // Click on drop zone to open file dialog
    dropZone.addEventListener('click', () => {
      fileInput.click();
    });

    // File input handler
    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (file) {
        try {
          await loadModelFromFile(file);
        } catch (error) {
          console.error(error);
          // Error is already shown by loadModelFromFile
        }
      }
    });

    // Load file button
    document.getElementById('load-file').addEventListener('click', async () => {
      const file = fileInput.files[0];
      if (file) {
        try {
          await loadModelFromFile(file);
        } catch (error) {
          console.error(error);
          // Error is already shown by loadModelFromFile
        }
      } else {
        showError('Please select a file first.');
      }
    });

    // Load from URL button
    document.getElementById('load-url').addEventListener('click', async () => {
      const url = document.getElementById('url-input').value.trim();
      try {
        await loadModel(url);
      } catch (e) {
        console.error(e);
        // Error is already shown by loadModel
      }
    });

    // Allow Enter key to trigger URL load
    document.getElementById('url-input').addEventListener('keypress', async (e) => {
      if (e.key === 'Enter') {
        const url = e.target.value.trim();
        try {
          await loadModel(url);
        } catch (error) {
          console.error(error);
          // Error is already shown by loadModel
        }
      }
    });

    // Buttons
    document.getElementById('export-scene').addEventListener('click', async () => {
      updateStatus('Exporting scene...', 'info');
      showLoading('Exporting scene to GLB...');
      try {
        const glb = await exportToGLB(scene);
        downloadArrayBuffer(glb, 'kitchen_chimney_scene.glb');
        updateStatus('Scene exported successfully!', 'success');
        hideLoading();
      } catch (e) {
        console.error(e);
        const errorMsg = `Export failed: ${e.message || 'Unknown error'}`;
        updateStatus(errorMsg, 'error');
        showError(errorMsg);
        hideLoading();
      }
    });

    document.getElementById('export-chimney').addEventListener('click', async () => {
      updateStatus('Exporting chimney...', 'info');
      showLoading('Exporting chimney to GLB...');
      try {
        // Export the loaded model if available, otherwise export the built chimney group
        const objectToExport = loadedModel || chimneyGroup;
        const tempScene = new THREE.Scene();
        const clone = objectToExport.clone(true);
        tempScene.add(clone);

        const glb = await exportToGLB(tempScene);
        downloadArrayBuffer(glb, 'kitchen_chimney_model.glb');
        updateStatus('Chimney exported successfully!', 'success');
        hideLoading();
      } catch (e) {
        console.error(e);
        const errorMsg = `Export failed: ${e.message || 'Unknown error'}`;
        updateStatus(errorMsg, 'error');
        showError(errorMsg);
        hideLoading();
      }
    });

    // Demo load button - replace URL with your GLTF/GLB URL if you have one
    document.getElementById('load-sample').addEventListener('click', async () => {
      try {
        // Demo file from CDN (public small gltf). Replace with your path, e.g. '/models/mychimney.glb'
        const demoUrl = 'https://cdn.jsdelivr.net/gh/KhronosGroup/glTF-Sample-Models@master/2.0/Box/glTF/Box.gltf';
        await loadModel(demoUrl);
      } catch (e) {
        console.error(e);
        // Error is already shown by loadModel
      }
    });

    // Render loop
    function animate() {
      requestAnimationFrame(animate);
      controls.update(); // Update controls in animation loop (required for damping)
      renderer.render(scene, camera);
    }
    animate();

    // Responsive
    window.addEventListener('resize', () => {
      camera.aspect = wrap.clientWidth / wrap.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(wrap.clientWidth, wrap.clientHeight);
    });
  </script>
</body>
</html>

